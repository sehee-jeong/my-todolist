# MY-TODOLIST 프로젝트 발표 대본 (교재 순서)

---

## 오프닝 (30초)

안녕하세요. 오늘 제가 발표할 주제는 "Vibe Coding으로 완성한 MY-TODOLIST 프로젝트"입니다.

여러분은 혹시 "Vibe Coding"이라는 단어를 들어보셨나요? AI 전문가 Andrej Karpathy가 처음 제시한 개념으로, AI와 함께하는 새로운 개발 패러다임입니다.

저는 Vibe Coding 교재를 기반으로 이 방식을 실제로 적용해서 단 4일 만에 풀스택 웹 애플리케이션을 완성했습니다. 오늘은 교재의 순서를 따라가면서, 각 단계에서 어떻게 Vibe Coding을 적용했는지 공유하겠습니다.

---

## 1. Vibe Coding 개요 (5분)

### Vibe Coding이란?

먼저 Vibe Coding이 무엇인지 설명드리겠습니다.

Vibe Coding은 AI 전문가 Andrej Karpathy가 처음 제시한 개념입니다. **개발자가 생성형 인공지능의 도움을 받아 자연어 프롬프트를 통해 코드를 작성하는 프로그래밍 방식**입니다.

어떻게 작동하냐면, 개발자가 Project나 Task를 LLM에 설명하면, LLM이 프롬프트를 기반으로 코드를 생성합니다. 그러면 개발자는 그 결과를 평가하고 LLM에 개선사항을 요청하는 방식으로 개발이 진행됩니다. 핵심은 코드를 세세하게 관리하지 않고, **반복적인 실험에 집중**한다는 것입니다.

### Vibe Coding의 특징

Vibe Coding에는 세 가지 주요 특징이 있습니다.

첫째, **자연어 기반 개발**입니다. 영어든 한국어든 모국어로 작성한 프롬프트만 입력하면 원하는 결과를 얻을 수 있습니다.

둘째, **AI 의존적 코딩**입니다. 코드의 작동 원리를 완전히 이해하지 않아도 코드를 작성할 수 있습니다. 이게 논란이 되기도 하지만, 빠른 프로토타이핑에는 매우 유용합니다.

셋째, **직감적 접근**입니다. 사전에 엄밀한 논리나 설계를 바탕으로 하지 않고, 직감과 느낌에 의존해서 프로그래밍을 진행합니다.

### 기존 코딩 vs Vibe Coding

화면의 표를 보시면 기존 코딩과 Vibe Coding의 차이를 한눈에 비교할 수 있습니다.

**개발자의 역할**이 달라집니다. 기존에는 설계자, 개발자, 디버거를 모두 담당했다면, Vibe Coding에서는 프롬프트 작성, 가이드, 테스터 역할을 합니다.

**코드 생성** 방식도 다릅니다. 기존에는 개발자가 직접 작성했지만, Vibe Coding에서는 AI가 자동으로 생성합니다.

**전문 지식** 요구 수준도 낮아집니다. 기존에는 높은 프로그래밍 언어 지식이 필요했지만, Vibe Coding에서는 상대적으로 낮은 기술적 지식만으로도 개발이 가능합니다.

**개발 속도**는 프로토타입 단계에서 훨씬 빠릅니다. 기존 방식은 체계적이지만 느린 반면, Vibe Coding은 빠른 반복이 가능합니다.

**디버깅** 방식도 변화합니다. 기존에는 수동으로 코드를 이해해야 했지만, Vibe Coding에서는 AI 피드백 기반으로 반복적으로 자동 수정합니다.

### VDD (Vibe-Driven Development)

교재에서 소개하는 중요한 개념 중 하나가 바로 **VDD**, Vibe-Driven Development입니다.

전통적인 SDLC는 계획, 설계, 구현, 테스트, 배포 순으로 진행됩니다. 반면 VDD는 아이디어에서 시작해서 **프롬프트 기반 설계**, **프롬프트 기반 구현**, 테스트, 그리고 **개선 반복**이라는 사이클을 빠르게 돕니다.

핵심은 빠른 피드백 루프와 점진적 개선입니다. 한 번에 완벽한 설계를 하는 것이 아니라, 빠르게 만들고, 테스트하고, 개선하는 것을 반복합니다.

### TDD vs VDT

테스트 방법론도 달라집니다. 기존의 **TDD**는 Test-Driven Development로, Red → Green → Refactor 사이클을 따릅니다. 테스트 코드를 먼저 작성하고, 모든 요구사항을 안정적으로 검증하는 것이 목표입니다.

반면 **VDT**, Vibe-Driven Testing은 **Vibe → Test → Refine** 사이클을 따릅니다. 현재 개발 흐름과 AI 피드백을 활용해서 핵심 기능과 위험 지점을 신속하게 검증하는 것이 목표입니다.

실제로 저는 이 프로젝트에서 VDT 방식으로 119개의 테스트를 작성했고, 커버리지는 94~95%를 달성했습니다.

### AI-DLC

또 하나 중요한 개념이 **AI-DLC**, AI-Driven Life Cycle입니다.

이것은 AI를 SDLC의 '중심 동료'로 두고, 모든 개발 단계에 AI를 일관되게 활용하는 방법론입니다. 요구사항 분석부터 설계, 구현, 테스트까지 모든 단계에서 AI를 활용합니다.

목표는 속도와 품질을 동시에 끌어올리는 것인데, 교재에서는 수십 배까지도 가능하다고 합니다.

### CI/CD와 Vibe Coding

마지막으로, Vibe Coding은 CI/CD와 궁합이 매우 좋습니다.

왜냐하면, Vibe Coding은 작은 단위의 변경이 많고, 계속 바뀌는 요구사항에 빠르게 대응하며, AI가 주도적으로 테스트를 작성하기 때문입니다. 또한 운영 피드백을 빠르게 반영할 수 있습니다.

실제로 저는 GitHub Actions와 Vercel을 활용해서 완전 자동화된 배포 파이프라인을 구축했습니다.

---

## 2. 환경 설정 (2분)

### 개발 환경 구성

Vibe Coding을 시작하려면 적절한 개발 환경이 필요합니다.

필수 도구로는 Node.js 18 이상, PostgreSQL 17, Git과 GitHub, 그리고 VS Code나 Cursor AI가 있습니다. 가장 중요한 것은 **Claude Code CLI**입니다.

### Claude Code 설정

Claude Code는 터미널 기반의 AI 코딩 어시스턴트입니다. npm으로 간단하게 설치할 수 있습니다.

설치 후에는 MCP, 즉 Model Context Protocol 설정이 필요합니다. `.mcp.json` 파일로 필요한 서버들을 구성하는데, 예를 들어 PostgreSQL과 연동하려면 postgresql-mcp 서버를 설정합니다.

### 프로젝트 초기화

프로젝트를 시작할 때는 먼저 GitHub 리포지토리를 생성합니다. `gh repo create` 명령으로 리포지토리를 만들고, 클론한 후 VS Code나 Cursor로 엽니다.

이렇게 기본 환경 설정이 완료되면 본격적인 개발을 시작할 수 있습니다.

---

## 3. 프롬프트 엔지니어링 (3분)

### 프롬프트의 중요성

Vibe Coding에서 가장 중요한 것은 바로 프롬프트입니다. 명확하고 구체적인 프롬프트를 작성해야 정확한 결과를 얻을 수 있습니다.

좋은 프롬프트의 조건은 네 가지입니다. 명확한 컨텍스트를 제공하고, 구체적인 요구사항을 전달하며, 제약조건을 명시하고, 예상 결과를 설명하는 것입니다.

### 계층적 컨텍스트 전략

교재에서 강조하는 것은 **계층적 컨텍스트 관리**입니다.

가장 상위에는 CLAUDE.md라는 전역 설정이 있고, 그 아래 프로젝트 메모리(MEMORY.md), 도메인 정의서, PRD(요구사항), 설계 원칙, 실행 계획이 순차적으로 연결됩니다.

이렇게 계층적으로 구성하면 AI가 프로젝트의 전체 컨텍스트를 이해하고 일관된 코드를 생성할 수 있습니다. 각 계층이 다음 계층의 기반이 되는 것이죠.

### CLAUDE.md 작성

CLAUDE.md는 AI에게 주는 지침서입니다.

전역 지침에는 프로젝트 전반에 적용되는 원칙을 작성합니다. 예를 들어, "간단한 코드는 주석을 지정하지 않고, 복잡한 코드일 때만 주석을 부여한다"는 식입니다.

또한 "오버엔지니어링 금지"와 "지침에 있는 기능만 정확하게 구현"이라는 제약을 명시해서, AI가 창의적으로 불필요한 작업을 하지 않도록 제어합니다.

### 하위 CLAUDE.md

백엔드나 프론트엔드 같은 하위 디렉토리에는 해당 영역에 특화된 CLAUDE.md를 작성합니다.

예를 들어 백엔드 CLAUDE.md에는 "SOLID 원칙 준수", "Clean 아키텍처 준수"같은 아키텍처 원칙과, "Node.js + Express + TypeScript 사용", "PostgreSQL은 pg 드라이버 사용, Prisma 금지" 같은 기술 스택을 명시합니다.

이렇게 하면 AI가 백엔드 개발을 할 때 이 지침을 따르게 됩니다.

---

## 4. Vibe Coding 도구 (3분)

### Claude Code CLI

Vibe Coding의 핵심 도구는 Claude Code CLI입니다.

터미널 기반의 AI 코딩 어시스턴트로, 파일을 읽고 쓸 수 있고, 코드를 생성하거나 수정할 수 있으며, Git과 통합되어 있어서 커밋이나 PR 생성도 자동으로 할 수 있습니다.

### MCP 서버

MCP는 Model Context Protocol의 약자로, AI가 외부 시스템과 통신할 수 있게 해주는 프로토콜입니다.

저는 PostgreSQL MCP로 데이터베이스와 연동하고, Supabase MCP로 프로덕션 DB와 연동했으며, Playwright MCP로 E2E 테스트를 자동화하고, Chrome DevTools MCP로 브라우저 디버깅을 자동화했습니다.

### 서브에이전트 (Subagent)

교재에서 강조하는 중요한 개념이 **서브에이전트**입니다.

서브에이전트는 특정 역할에 특화된 AI 에이전트입니다. Plan Agent는 구현 계획을 수립하고, Explore Agent는 코드베이스를 탐색하며, Backend Developer는 백엔드 개발을, Frontend Developer는 프론트엔드 개발을 담당합니다.

중요한 점은 이 서브에이전트들을 **병렬로 실행**할 수 있다는 것입니다. 예를 들어 코드 분석과 이슈 확인을 동시에 진행할 수 있습니다.

### 사용자 정의 Command

가장 강력한 도구는 **사용자 정의 Command**입니다.

`.claude/commands/` 디렉토리에 마크다운 파일로 작성하는데, 예를 들어 `issue-resolver-backend.md`는 GitHub Issue 번호를 받아서 자동으로 이슈를 해결하는 커맨드입니다.

이슈 확인, 브랜치 생성, 코드 분석, 계획 수립, 테스트 작성, 문제 해결, 테스트 수행까지 전체 프로세스를 자동화할 수 있습니다.

실제로 저는 이 커맨드로 백엔드와 프론트엔드의 모든 이슈를 처리했습니다.

---

## 5. 프로젝트 기획 및 설계 (4분)

### 도메인 정의서

교재에서는 프로젝트 시작 전에 **도메인 정의서**를 작성하는 것을 강조합니다.

도메인 정의서란 특정 업무나 제품이 다루는 문제 영역을 공통 언어로 정리해서, 범위, 개념, 규칙, 경계를 명확히 하는 기준 문서입니다.

핵심 항목으로는 비즈니스 컨텍스트(목적, 비전, 범위), 도메인 언어(용어 사전), 도메인 모델(엔티티, 값 객체, 애그리게이트), 비즈니스 규칙, 업무 프로세스가 있습니다.

### 도메인 정의서 작성 프롬프트

도메인 정의서도 AI로 작성할 수 있습니다.

프롬프트에는 문제 정의, 주요 기능, 필수 사항을 명확하게 작성합니다. 예를 들어 "너는 최고의 비즈니스 도메인 전문가야. MY-TODOLIST 할 일 관리 애플리케이션의 도메인 정의서 초안을 작성해줘"라고 요청하면서, 문제 정의와 주요 기능을 나열합니다.

중요한 것은 "핵심 내용만 포함하고, docs/1-domain-definition.md로 저장해줘"처럼 구체적으로 지시하는 것입니다.

### PRD (Product Requirements Document)

도메인 정의서 다음에는 **PRD**를 작성합니다.

도메인 정의서는 "무엇을"과 "왜"를 명확히 하지만, PRD는 여기에 "어떻게"와 "언제"가 추가됩니다. 도메인 정의서가 뼈대를 제공한다면, PRD는 살을 붙이는 추가 작업입니다.

PRD에는 타겟 사용자 페르소나, UI/UX 요구사항, 기술 스택 선택 근거, MVP 범위 정의, 성과 지표(KPI) 등이 포함됩니다.

### 실행 계획 수립

PRD가 완성되면 실행 계획을 수립합니다.

저는 프로젝트를 3개의 마일스톤으로 나누었습니다. M1은 DB와 백엔드 API로 1일, M2는 프론트엔드로 2일, M3는 테스트와 배포로 1일을 할당했습니다.

각 마일스톤은 다시 작은 Task들로 분할됩니다. 예를 들어 백엔드는 BE-01부터 BE-07까지 7개 태스크로 나누었습니다.

### GitHub Issue 생성

교재에서는 각 Task를 GitHub Issue로 관리하는 것을 권장합니다.

프롬프트로 "전문화된 서브에이전트를 이용해 실행 계획의 처리 단계를 유지하면서 GitHub 이슈를 생성해줘"라고 요청하면, AI가 자동으로 각 Task에 대한 Issue를 생성합니다.

각 Issue에는 Title에 Stage를 명시하고, Label로 종류, 영역, 복잡도를 표시하며, Todo 리스트, 완료 조건, 기술적 고려사항, 의존성(선행/후행 작업)을 모두 포함시킵니다.

이렇게 하면 개발 진행 상황을 투명하게 관리할 수 있고, 팀원들과 효과적으로 소통할 수 있습니다.

---

## 6. 백엔드 개발 (5분)

### PostgreSQL 설정

백엔드 개발의 첫 단계는 데이터베이스 설정입니다.

맥OS에서는 Homebrew로 PostgreSQL 17을 설치하고, `createdb todolist_dev` 명령으로 데이터베이스를 생성합니다. 그리고 .env 파일에 연결 문자열을 설정합니다.

### PostgreSQL MCP 연결

데이터베이스와 AI를 연결하려면 PostgreSQL MCP가 필요합니다.

.mcp.json 파일에 postgresql-mcp 서버를 설정하고, `/mcp` 명령으로 연결을 확인합니다. 그 다음 "postgresql-mcp를 이용해 로컬 데이터베이스에 연결되는지 테스트해줘"라고 프롬프트를 입력하면, AI가 자동으로 연결을 테스트합니다.

### 스키마 적용

스키마 적용도 실행 계획을 기반으로 진행합니다.

"@docs/7-execution-plan.md의 1.2 스키마 적용 및 검증 단계를 진행해줘"라고 요청하면, AI가 자동으로 database/schema.sql 파일을 실행하고, member와 todo 테이블을 생성하며, 인덱스를 생성하고, 제약조건을 검증합니다.

### 백엔드 개발 태스크

백엔드는 총 7개의 태스크로 구성됩니다.

BE-01은 프로젝트 초기화로 Express와 TypeScript를 설정합니다. BE-02는 DB 연결로 pg Pool을 구성합니다. BE-03은 Member Repository로 데이터 접근 계층을 분리합니다. BE-04는 인증 API로 회원가입과 로그인을 구현합니다. BE-05는 JWT 미들웨어입니다. BE-06은 Todo Repository이고, BE-07은 Todo API로 CRUD와 상태 전이를 구현합니다.

### Custom Command로 Issue 해결

여기서 교재의 핵심 기법이 등장합니다. 바로 **Custom Command**입니다.

앞서 작성한 `issue-resolver-backend.md` 커맨드를 사용하면, `/issue-resolver-backend 23`처럼 Issue 번호만 입력하면 됩니다.

그러면 AI가 자동으로 Issue 내용을 확인하고, feature-23 브랜치를 생성하며, 기존 코드를 분석하고, 계획을 수립하며, 테스트를 작성하고(커버리지 80% 이상), 문제를 해결하고, 테스트를 수행한 후, PR까지 생성합니다.

전체 프로세스가 자동화되는 것이죠. 저는 이 방식으로 백엔드의 모든 이슈를 처리했습니다.

### 로깅의 중요성

교재에서 특히 강조하는 것이 **로깅**입니다.

AI가 모든 것을 해결해주려면 대단히 많은 토큰과 시간이 필요합니다. 원인을 파악하기 위해 반복적인 분석 작업을 하게 되기 때문이죠.

따라서 충실하게 로깅하도록 개발하고, 로그를 기반으로 분석하도록 해야 합니다. 개발 환경에서는 상세하게 로깅하되, 프로덕션 환경에서는 에러만 로깅하는 logger 함수를 작성하는 것을 권장합니다.

디버깅할 때 단순한 에러 메시지뿐만 아니라 로그에 기록된 것을 직접 AI에게 알려주면 훨씬 빠르게 해결할 수 있습니다.

### 완성된 백엔드 API

이렇게 해서 완성된 백엔드 API는 총 35개의 엔드포인트를 가지고 있습니다.

회원 인증(signup, login, refresh, logout), 할 일 CRUD, 상태 전이(complete, revert)가 모두 구현되었고, JWT 미들웨어와 에러 핸들링도 완비되었습니다. Swagger UI로 자동 생성된 API 문서도 있습니다.

---

## 7. 프론트엔드 개발 (5분)

### 스타일 가이드 생성

프론트엔드 개발의 첫 단계는 스타일 가이드 생성입니다.

교재에서 소개하는 흥미로운 기법이 있는데, 바로 **화면 캡처를 이용한 스타일 추출**입니다.

원하는 디자인의 화면을 캡처한 후, Alt+V로 Claude Code에 이미지를 첨부하고, "이 화면 이미지 정보를 참조하여 tailwind를 적용할 때의 스타일 가이드를 생성하여 @docs/APP_STYLE_GUIDE.md 파일로 저장해줘"라고 요청하면, AI가 자동으로 색상, 폰트, 컴포넌트 스타일을 추출해서 가이드를 만들어줍니다.

### Custom Command 생성

프론트엔드도 백엔드와 유사하게 Custom Command를 작성합니다.

`.claude/commands/issue-resolver-frontend.md` 파일을 만드는데, 백엔드와 다른 점은 추가로 참조하는 문서들이 있다는 것입니다. Wireframes, Swagger, User Scenario, Style Guide를 모두 참조합니다.

### 프론트엔드 개발 태스크

프론트엔드도 7개의 태스크로 구성됩니다.

FE-01은 프로젝트 초기화로 Vite와 React 19를 설정합니다. FE-02는 API Service 레이어로 백엔드 API 호출을 추상화합니다. FE-03은 인증 페이지로 회원가입과 로그인을 구현합니다. FE-04는 할 일 목록, FE-05는 생성과 수정 페이지입니다. FE-06은 Overdue 시각화로 마감 초과 항목을 강조 표시하고, FE-07은 반응형 UI를 구현합니다.

### Custom Command로 개발

백엔드와 마찬가지로 `/issue-resolver-frontend 45`처럼 Issue 번호만 입력하면, AI가 자동으로 전체 프로세스를 진행합니다.

Issue 확인과 문서 분석, feature-45 브랜치 생성, 코드베이스 분석을 병렬로 수행하고, 계획을 수립하며, 테스트 작성과 문제 해결을 병렬로 진행한 후, 테스트를 수행합니다.

### 프론트엔드 개발 주의사항

교재에서 강조하는 주의사항이 있습니다.

첫째, **환경변수를 반드시 사용**해야 합니다. API URL을 하드코딩하지 말고 `import.meta.env.VITE_API_URL`처럼 환경변수로 관리해야 합니다.

둘째, **기술 스택을 명시**해야 합니다. frontend/CLAUDE.md에 "API 호출은 axios 사용", "상태 관리는 React hooks", "스타일은 Tailwind CSS" 같은 식으로 명시하면, AI가 일관된 방식으로 코드를 생성합니다.

### Chrome DevTools MCP 활용

교재에서 소개하는 또 하나의 강력한 도구가 **Chrome DevTools MCP**입니다.

"chrome-devtools mcp를 사용해 네트워크 탭에서 실패한 요청들을 확인하고 상태 코드와 함께 정리해줘"라고 요청하면, AI가 자동으로 브라우저의 개발자 도구를 분석해서 문제를 찾아줍니다.

또는 "폼 제출 시 유효성 검사가 제대로 작동하는지 확인해줘"라고 요청하면, AI가 브라우저에서 직접 테스트를 수행합니다.

이렇게 하면 디버깅 시간을 크게 단축할 수 있습니다.

---

## 8. 배포 (5분)

### Supabase Database 설정

배포의 첫 단계는 프로덕션 데이터베이스를 준비하는 것입니다.

교재에서는 Supabase를 사용합니다. Supabase 대시보드에서 프로젝트를 생성할 때, Project Name은 자신만의 이름을 사용하고, Region은 Northeast Asia(Seoul)을 선택합니다.

그 다음 연결 문자열을 확인하는데, Transaction Pooler의 Connection String을 복사합니다. 이것은 나중에 환경변수로 사용됩니다.

### 로컬 → Supabase 마이그레이션

로컬 데이터베이스의 스키마를 Supabase로 마이그레이션해야 합니다.

먼저 .mcp.deploy.json 파일을 만들어서 supabase MCP와 postgresql-mcp를 설정합니다. 그 다음 `claude --mcp-config .mcp.deploy.json`으로 Claude Code를 실행합니다.

그리고 "postgresql-mcp와 supabase mcp를 이용해 로컬 데이터베이스의 스키마를 supabase로 마이그레이션 해줘"라고 요청하면, AI가 자동으로 테이블, 인덱스, 제약조건을 모두 마이그레이션합니다.

완료 후 Supabase 브라우저 화면에서 생성된 테이블을 확인할 수 있습니다.

### Vercel 배포

교재에서는 **Vercel for GitHub**을 사용합니다.

Vercel for GitHub의 장점은 설정이 매우 간단하다는 것입니다. GitHub 연동만 하면 자동으로 배포되고, main 브랜치는 Production 환경으로, 다른 브랜치는 Preview 환경으로 배포됩니다. HTTPS도 자동으로 적용되고, 별도의 CI/CD 파이프라인을 구성할 필요가 없습니다.

### 백엔드 배포

Vercel 대시보드에서 Add New → Project를 클릭하고, GitHub 리포지토리를 연결합니다.

프로젝트명은 my-todolist-backend로 지정하고, Root Directory는 `backend`로 선택합니다.

배포 후에는 환경변수를 설정해야 합니다. Settings → Environment Variables에서 DATABASE_URL(Supabase 연결 문자열), JWT_SECRET, JWT_REFRESH_SECRET, CORS_ORIGIN(프론트엔드 URL)을 입력합니다.

### 백엔드 배포 주의사항

교재에서 강조하는 중요한 주의사항이 있습니다.

Vercel은 Serverless Function 환경이기 때문에 **파일 시스템 쓰기가 제한**됩니다. /tmp 디렉토리만 쓰기가 가능합니다.

따라서 로그를 파일에 저장하도록 했다면 배포가 실패합니다. 해결책은 Console.log를 사용하는 것입니다. Vercel 대시보드의 Logs 화면에서 확인할 수 있습니다.

개발 환경과 프로덕션 환경을 구분하는 logger 함수를 만들어서 사용하는 것을 권장합니다.

### 프론트엔드 배포

프론트엔드도 동일한 방식으로 배포합니다.

프로젝트명은 my-todolist-frontend로 지정하고, Root Directory는 `frontend`로 선택합니다.

환경변수는 VITE_API_URL만 설정하면 되는데, 값은 백엔드 API의 URL입니다.

### 배포 완료

배포가 완료되면 세 개의 URL이 생성됩니다.

프론트엔드는 my-todolist-app.vercel.app, 백엔드 API는 my-todolist-api.vercel.app, API 문서는 /docs 경로에서 확인할 수 있습니다.

### CI/CD 파이프라인

Vercel for GitHub을 사용하면 CI/CD 파이프라인이 자동으로 구성됩니다.

Git Push를 하면 GitHub에 코드가 올라가고, Vercel이 자동으로 배포를 시작합니다. 빌드와 테스트를 수행한 후, Production 또는 Preview 환경으로 배포하고, Health Check까지 자동으로 수행합니다.

완전히 자동화된 배포 프로세스입니다.

---

## 9. 실제 개발 성과 (3분)

### 개발 기간 및 성과

이제 실제 개발 성과를 말씀드리겠습니다.

총 개발 기간은 4일이었습니다. M1 백엔드는 1일 동안 35개 엔드포인트와 35개 테스트를 작성했고, 커버리지는 94%를 달성했습니다. M2 프론트엔드는 2일 동안 7개 페이지와 84개 테스트를 작성했고, 커버리지는 95%입니다. M3 배포는 1일 동안 Vercel과 Supabase에 프로덕션 배포를 완료했습니다.

총 119개의 자동화 테스트를 작성했습니다.

### 성능 지표

모든 성능 목표를 달성했습니다.

API 응답 시간은 목표가 500ms 이하였는데, 실측값은 평균 40ms입니다. 할 일 목록 조회는 목표가 1초 이하였는데, 평균 3.6ms밖에 걸리지 않습니다. 테스트 커버리지는 목표가 90% 이상이었는데, 백엔드 94%, 프론트엔드 95%를 달성했습니다. 자동화 테스트는 119개 전부 통과했습니다.

### 구현된 기능

구현된 기능을 정리하면, 회원 인증 부분에서는 회원가입(이메일 중복 검사, 비밀번호 정책), 로그인(JWT Access Token + Refresh Token), 토큰 갱신(Token Rotation), 로그아웃이 있습니다.

할 일 관리에서는 CRUD(생성, 조회, 수정, 삭제), 상태 전이(PENDING과 DONE 간의 전환), 마감일 설정(날짜와 시간), 마감 초과 알림이 있습니다.

사용자 경험 측면에서는 상태별 필터(전체/진행중/완료), 다크모드와 라이트모드와 시스템 테마, 다국어 지원(한국어/영어/일본어), 반응형 UI(모바일 360px 이상)를 구현했습니다.

품질 보증 측면에서는 119개 자동화 테스트, 커버리지 94~95%, CI/CD 파이프라인을 구축했습니다.

---

## 10. 회고 및 배운 점 (4분)

### Vibe Coding의 장점

Vibe Coding을 경험하면서 느낀 장점을 말씀드리겠습니다.

첫째, **개발 속도가 비약적으로 향상**됩니다. 4일 만에 풀스택 애플리케이션을 완성했고, 보일러플레이트 코드를 자동으로 생성하며, 테스트 코드까지 자동화할 수 있었습니다.

둘째, **품질이 향상**됩니다. 119개의 자동화 테스트를 작성했고, 커버리지는 94~95%에 달합니다. TypeScript의 strict mode를 활용해서 타입 안정성도 확보했습니다.

셋째, **학습 효과**가 뛰어납니다. 최신 기술 스택을 빠르게 습득할 수 있었고, 베스트 프랙티스를 적용하며, 아키텍처 패턴을 깊이 이해할 수 있었습니다.

넷째, **VDD를 실천**할 수 있었습니다. 빠른 피드백 루프, 점진적 개선, AI-DLC 적용이 가능했습니다.

### 주요 도전 과제

물론 도전 과제도 있었습니다.

첫째, **프롬프트 엔지니어링**입니다. 명확한 요구사항을 정의하고, 컨텍스트를 관리하며, 단계별로 검증하는 것이 중요했습니다.

둘째, **AI 생성 코드 검토**입니다. 보안 취약점을 확인하고, 비즈니스 로직을 검증하며, 오버엔지니어링을 방지해야 했습니다.

셋째, **통합 과정**입니다. 프론트엔드와 백엔드의 API 연동, CORS 정책 관리, 환경변수 설정에서 세심한 주의가 필요했습니다.

넷째, **배포 환경**입니다. Serverless의 제약사항을 이해하고, 로깅 전략을 변경하며, 환경별 설정을 관리해야 했습니다.

### Vibe Coding 권장 사항

Vibe Coding을 시작하려는 분들께 권장 사항을 드리자면,

첫째, **명확한 설계를 먼저** 하세요. 도메인 정의서, PRD, 실행 계획, 아키텍처 다이어그램을 작성하세요.

둘째, **단계별로 진행**하세요. 작은 태스크로 분할하고, GitHub Issue로 관리하며, 각 단계를 검증하세요.

셋째, **VDT를 적용**하세요. Vibe → Test → Refine 사이클로 진행하고, 커버리지 80% 이상을 유지하며, E2E 시나리오를 작성하세요.

넷째, **문서화**하세요. 프로젝트 메모리(MEMORY.md), CLAUDE.md(계층적 지침), API 문서화(Swagger), README를 작성하세요.

다섯째, **도구를 활용**하세요. 서브에이전트를 적극 활용하고, Custom Command를 작성하며, MCP 서버를 연동하고, CI/CD를 자동화하세요.

여섯째, **검토를 필수**로 하세요. AI 생성 코드를 검토하고, 오버엔지니어링을 방지하며, 보안 취약점을 확인하세요.

### 교재의 핵심 교훈

교재를 통해 배운 핵심 교훈을 정리하면,

**VDD**(Vibe-Driven Development)는 빠른 피드백 루프와 점진적 개선을 가능하게 합니다.

**AI-DLC**(AI-Driven Life Cycle)는 모든 개발 단계에 AI를 일관되게 활용하는 방법론입니다.

**VDT**(Vibe-Driven Testing)는 개발 흐름과 AI 피드백 기반으로 테스트를 작성합니다.

**CI/CD 통합**은 Vibe Coding과 자동화의 시너지를 만들어냅니다.

### 핵심 메시지

마지막으로 핵심 메시지를 전달하겠습니다.

Vibe Coding은 개발 속도를 높이고, 코드 품질을 향상시키며, 학습 효과를 극대화합니다.

"어떻게"보다 "무엇을"에 집중하면, 더 나은 제품을 만들 수 있습니다.

**단, 명확한 설계와 검토는 필수입니다!**

AI가 아무리 똑똑해도, 최종적인 책임은 개발자에게 있습니다. AI는 도구이고, 우리는 설계자이자 검토자입니다.

---

## 클로징 (30초)

오늘 발표를 통해 Vibe Coding 교재의 8개 챕터를 순서대로 따라가면서, 실제 프로젝트에 어떻게 적용했는지 공유했습니다.

Vibe Coding은 단순히 개발 속도를 높이는 것을 넘어, 개발자가 더 창의적이고 전략적인 사고에 집중할 수 있게 해줍니다. "어떻게"보다 "무엇을"에 집중하면서, 더 나은 제품을 만들 수 있었습니다.

여러분도 교재를 참고해서 Vibe Coding을 시작해보시기 바랍니다. VDD, AI-DLC, VDT 같은 방법론을 적용하고, 서브에이전트와 Custom Command 같은 도구를 활용하면, 놀라운 생산성을 경험하실 수 있을 것입니다.

**감사합니다!**

질문이 있으시면 편하게 해주세요.

---

## 예상 질문 및 답변

**Q1: 교재의 VDD와 전통적인 애자일의 차이는 무엇인가요?**

A: 좋은 질문입니다. 애자일도 반복적인 개발을 강조하지만, VDD는 AI를 중심에 두고 훨씬 빠른 피드백 루프를 만든다는 차이가 있습니다. 애자일은 보통 1~2주 스프린트인 반면, VDD는 하루나 심지어 몇 시간 단위로 빠른 반복이 가능합니다. 또한 AI가 코드 생성부터 테스트까지 자동화하기 때문에, 개발자는 요구사항 정의와 검토에 더 집중할 수 있습니다.

**Q2: 서브에이전트를 어떻게 효과적으로 활용하나요?**

A: 서브에이전트의 핵심은 **역할 분리와 병렬 실행**입니다. 예를 들어 Issue를 해결할 때, Issue 확인, 브랜치 생성, 코드 분석을 병렬로 수행할 수 있습니다. 또한 각 서브에이전트는 특정 역할에 특화되어 있기 때문에, Plan Agent에게는 계획 수립을, Backend Developer에게는 코드 작성을 맡기는 식으로 적재적소에 활용하는 것이 중요합니다.

**Q3: Custom Command를 만들 때 주의할 점은 무엇인가요?**

A: 세 가지를 강조하고 싶습니다. 첫째, **명확한 단계 정의**입니다. 각 단계가 무엇을 하는지 구체적으로 작성해야 합니다. 둘째, **병렬 실행 지시**입니다. 독립적인 작업은 병렬로 수행하도록 명시하면 속도가 빨라집니다. 셋째, **참조 문서 명시**입니다. @docs/ 경로를 사용해서 참조할 문서를 명확히 지정하면, AI가 컨텍스트를 정확히 이해합니다.

**Q4: VDT로 작성한 테스트의 품질을 어떻게 보장하나요?**

A: VDT로 작성한 테스트도 반드시 검토해야 합니다. 저는 세 가지 방법을 사용했습니다. 첫째, **커버리지 목표 설정**입니다. 80% 이상을 요구했고, 실제로 94~95%를 달성했습니다. 둘째, **수동 테스트 병행**입니다. AI가 생성한 테스트만 믿지 않고, 직접 브라우저에서 테스트도 했습니다. 셋째, **E2E 시나리오 작성**입니다. 실제 사용자 시나리오를 Playwright로 작성해서 전체 플로우를 검증했습니다.

**Q5: 도메인 정의서를 AI로 작성하면 품질이 떨어지지 않나요?**

A: 그럴 수 있습니다. 그래서 교재에서는 **AI가 초안을 작성하고, 개발자가 검토하고 수정하는 프로세스**를 강조합니다. AI가 생성한 도메인 정의서를 다시 AI에게 평가하도록 요청할 수도 있습니다. "완전성, 명확성, 추적성, 검증 가능성, 유지보수성" 이 5가지 기준으로 평가하고, 부족한 부분을 보완하는 반복 과정을 거칩니다.

**Q6: Supabase 마이그레이션 중 문제가 생기면 어떻게 하나요?**

A: 두 가지 MCP를 모두 사용하는 것이 핵심입니다. postgresql-mcp로 로컬 DB의 스키마를 확인하고, supabase mcp로 원격 DB를 확인하면서, AI가 자동으로 차이를 비교하고 마이그레이션합니다. 문제가 생기면 Supabase 대시보드의 SQL Editor에서 직접 확인할 수 있고, 해당 로그를 AI에게 제공하면 빠르게 해결할 수 있습니다.

**Q7: Serverless 환경의 제약은 어떻게 해결하나요?**

A: 교재에서 강조하는 것처럼, **환경별로 다른 설정을 사용**해야 합니다. 로컬 환경에서는 파일 시스템에 로깅해도 되지만, Vercel Serverless 환경에서는 Console.log를 사용해야 합니다. logger 함수를 만들어서 `process.env.NODE_ENV`로 환경을 구분하면 됩니다. 또한 Vercel의 Logs 화면에서 실시간으로 로그를 확인할 수 있어서, 파일 로깅이 없어도 충분합니다.

**Q8: 프롬프트 엔지니어링에서 가장 중요한 것은 무엇인가요?**

A: **계층적 컨텍스트 관리**입니다. CLAUDE.md부터 시작해서 MEMORY.md, 도메인 정의서, PRD, 설계 원칙, 실행 계획으로 이어지는 계층 구조를 만들면, AI가 프로젝트 전체를 이해합니다. 또한 각 단계에서 "@docs/파일명"으로 문서를 명시적으로 참조하면, AI가 정확한 컨텍스트를 가지고 작업합니다. 프롬프트 하나하나보다 이런 구조가 더 중요합니다.

**Q9: AI-DLC를 실제로 적용하려면 어디서부터 시작해야 하나요?**

A: 교재 순서를 그대로 따라가시면 됩니다. 첫째, 도메인 정의서를 AI로 작성하고 검토합니다. 둘째, PRD를 AI로 확장합니다. 셋째, 실행 계획을 수립하고 GitHub Issue를 생성합니다. 넷째, Custom Command를 작성해서 각 Issue를 자동으로 해결합니다. 다섯째, 테스트도 AI로 작성하고 검토합니다. 여섯째, 배포도 AI의 도움을 받아 진행합니다. 모든 단계에서 AI를 일관되게 활용하는 것이 핵심입니다.

**Q10: 4일 개발의 비결은 무엇인가요?**

A: 세 가지입니다. 첫째, **명확한 설계**입니다. 도메인 정의서와 PRD를 먼저 작성해서 무엇을 만들지 명확히 했습니다. 둘째, **자동화**입니다. Custom Command로 Issue 해결 전체 프로세스를 자동화했고, CI/CD로 배포도 자동화했습니다. 셋째, **VDD와 VDT 적용**입니다. 빠른 피드백 루프로 개발하고, AI 기반 테스트로 품질을 보장했습니다. 교재의 방법론을 충실히 따른 것이 가장 큰 비결입니다.
