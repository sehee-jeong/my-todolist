# MY-TODOLIST 프로젝트 발표 대본

---

## 오프닝 (30초)

안녕하세요. 오늘 제가 발표할 주제는 "Vibe Coding으로 완성한 MY-TODOLIST 프로젝트"입니다.

여러분은 혹시 "Vibe Coding"이라는 단어를 들어보셨나요? 최근 개발 패러다임이 크게 변화하고 있습니다. AI를 단순한 도구가 아닌, 협업 파트너로 활용하는 새로운 개발 방식이 등장했는데요, 바로 "Vibe Coding"입니다.

저는 이 Vibe Coding 방식을 활용해서 단 4일 만에 풀스택 웹 애플리케이션을 완성했습니다. 오늘은 그 과정과 결과를 여러분과 공유하고자 합니다.

---

## 1. Vibe Coding이란? (3분)

먼저 Vibe Coding이 무엇인지 설명드리겠습니다.

**Vibe Coding의 핵심은 AI와 함께하는 협업 개발입니다.** 기존에는 개발자가 모든 코드를 직접 작성해야 했다면, 이제는 AI를 코딩 파트너로 활용하여 "무엇을" 만들지에 집중하고, "어떻게" 만들지는 AI와 함께 해결하는 방식입니다.

화면에 보시는 표를 보시면, 기존 개발 방식과 Vibe Coding의 차이를 한눈에 비교할 수 있습니다.

**기존 개발 방식**에서는 코드 작성 방법에 초점을 맞추고, 모든 코드를 직접 작성해야 하므로 속도가 느립니다. 또한 문법과 라이브러리를 모두 익혀야 하는 가파른 학습 곡선을 가지고 있죠.

반면 **Vibe Coding**은 문제 정의와 요구사항에 초점을 맞춥니다. AI가 보일러플레이트 코드를 자동으로 생성해주기 때문에 개발 속도가 빠르고, 의도 전달이 핵심이므로 학습 곡선이 완만합니다. 개발자의 역할은 모든 것을 담당하는 것이 아니라, 설계자이자 검토자로 변화합니다.

**여기서 중요한 것이 바로 프롬프트 엔지니어링입니다.** AI에게 정확한 의도를 전달하기 위해서는 명확한 컨텍스트를 제공하고, 구체적인 요구사항을 전달하며, 제약조건을 명시해야 합니다. 마치 팀원에게 업무를 명확하게 전달하는 것처럼 말이죠.

---

## 2. 프로젝트 개요 (2분)

이제 제가 만든 MY-TODOLIST 프로젝트에 대해 소개하겠습니다.

**프로젝트의 비전은 간단합니다.** "이메일 인증 기반으로 개인의 할 일을 안전하게 관리할 수 있는 웹 애플리케이션"을 만드는 것이었습니다.

**핵심 기능은 크게 6가지입니다.**
1. 회원가입과 로그인 - JWT와 Refresh Token을 활용한 안전한 인증
2. 할 일 CRUD - 생성, 조회, 수정, 삭제의 기본 기능
3. 마감일 설정 - 날짜와 시간까지 정확하게 설정 가능
4. 상태별 필터 - 전체, 진행중, 완료 탭으로 쉽게 필터링
5. 마감 초과 알림 - 지난 마감일을 시각적으로 표시
6. 다크모드와 다국어 지원 - 한국어, 영어, 일본어 3개 언어 지원

**기술 스택을 보시면**, 프론트엔드는 최신 React 19와 TypeScript, Vite를 사용했고, 백엔드는 Node.js와 Express, 데이터베이스는 PostgreSQL 17을 Supabase에서 호스팅했습니다. 인증은 JWT와 Refresh Token을 활용했고, 배포는 Vercel을 사용했습니다. 테스트는 백엔드는 Jest, 프론트엔드는 Vitest, E2E는 Playwright를 활용했습니다.

**개발 기간은 총 4일**이었습니다. 첫째 날 백엔드를 개발하고, 둘째 날과 셋째 날 프론트엔드를 개발했으며, 마지막 날 테스트와 배포를 완료했습니다.

---

## 3. 기획 및 설계 (3분)

모든 성공적인 프로젝트는 탄탄한 기획과 설계에서 시작됩니다. Vibe Coding에서도 마찬가지입니다. 오히려 AI와 협업하기 때문에 더욱 명확한 설계가 필요합니다.

**먼저 도메인을 정의했습니다.** 핵심 엔티티는 두 가지입니다.

첫 번째, **Member(회원)**입니다. 이메일 인증 기반으로 동작하며, 비밀번호는 bcrypt로 암호화하고, 닉네임을 가집니다.

두 번째, **Todo(할 일)**입니다. 제목은 필수, 설명은 선택 사항이며, 마감일은 TIMESTAMPTZ 타입으로 날짜와 시간을 모두 저장합니다. 상태는 PENDING 또는 DONE, 두 가지만 존재합니다.

**중요한 비즈니스 규칙들도 정의했습니다.** 예를 들어, 이메일은 중복될 수 없고, 비밀번호는 최소 8자 이상이며 영문과 숫자를 반드시 포함해야 합니다. 또한 본인이 소유한 할 일만 접근할 수 있으며, 마감일이 현재 시각보다 이전이고 상태가 PENDING이면 overdue로 표시됩니다.

**ERD를 보시면**, Member와 Todo는 1대다 관계입니다. 한 명의 회원이 여러 개의 할 일을 가질 수 있죠.

**아키텍처는 전통적인 3-Tier 구조**를 따랐습니다. Presentation 계층에는 React 19와 TypeScript가, Application 계층에는 Node.js와 Express가, Data 계층에는 PostgreSQL이 위치합니다. 각 계층은 HTTP/JSON으로 통신하며, JWT 미들웨어가 인증을 담당합니다.

**프로젝트 구조는 frontend와 backend로 명확히 분리**했습니다. 백엔드는 controllers, services, repositories, middlewares, routes, config로 계층을 나누어 책임을 분리했고, 프론트엔드는 pages, components, hooks, services로 구성했습니다. 또한 모든 설계 문서는 docs 폴더에 저장했습니다.

---

## 4. 개발 환경 설정 (2분)

Vibe Coding을 위해서는 적절한 도구가 필요합니다.

**주요 도구는 Claude Code CLI**입니다. 이것은 터미널 기반의 AI 코딩 어시스턴트로, 파일을 읽고 쓸 수 있고, 코드를 생성하거나 수정할 수 있으며, Git과 통합되어 커밋이나 PR 생성도 자동으로 할 수 있습니다.

**프롬프트 전략은 계층적으로 구성**했습니다. 가장 상위에는 CLAUDE.md라는 전역 설정이 있고, 그 아래 프로젝트별 메모리, 도메인 정의서, PRD(요구사항 문서), 설계 원칙, 실행 계획이 순차적으로 연결됩니다. 이렇게 하면 AI가 프로젝트의 전체 컨텍스트를 이해하고 일관된 코드를 생성할 수 있습니다.

**개발 환경은 Node.js 18 이상, PostgreSQL 17, VS Code와 TypeScript, 그리고 Git과 GitHub**를 사용했습니다.

**초기 세팅 프롬프트 예시**를 보시면, "React 19 + TypeScript + Vite로 프론트엔드 프로젝트를 초기화해줘"라고 자연어로 요청하면서, strict 모드 활성화, react-router-dom 설치, API 서비스 레이어 구조 포함, ESLint 설정 등 구체적인 요구사항을 명시했습니다. 이렇게 명확하게 요청하면 AI가 정확한 결과물을 생성합니다.

---

## 5. 백엔드 개발 (4분)

백엔드는 총 7개의 태스크로 나누어 개발했습니다. 각 태스크는 명확한 책임과 의존성을 가지고 있습니다.

**BE-01은 프로젝트 초기화**입니다. Express와 TypeScript를 설정하고, tsconfig.json에서 strict 모드를 활성화했습니다. 전역 에러 핸들러를 만들고, Health check 엔드포인트를 추가했습니다.

**BE-02는 DB 연결**입니다. PostgreSQL에 연결하기 위해 pg Pool을 사용했고, 환경변수는 .env 파일에서 로드했습니다. 연결에 실패하면 프로세스를 종료하도록 했습니다.

**BE-03은 Member Repository**입니다. 데이터 접근 계층을 분리하여, findByEmail로 이메일로 회원을 조회하고, create로 새 회원을 생성하는 인터페이스를 정의했습니다.

**BE-04는 인증 API**입니다. 회원가입 엔드포인트는 이메일 중복을 검사하고, 비밀번호 정책을 검증하며, bcrypt로 해싱합니다. 로그인 엔드포인트는 이메일을 조회하고 bcrypt로 비밀번호를 비교한 후, Access Token과 Refresh Token을 발급합니다. Access Token의 만료 시간은 15분, Refresh Token은 7일입니다.

**BE-05는 JWT 미들웨어**입니다. Authorization 헤더에서 Bearer 토큰을 파싱하고, 서명과 만료를 검증한 후, req.memberId에 회원 ID를 주입합니다.

**BE-06은 Todo Repository**입니다. findAllByMemberId로 회원의 모든 할 일을 조회하고, create, update, updateStatus, deleteById 등의 메서드를 제공합니다.

**BE-07은 Todo API**입니다. GET /api/todos로 목록을 조회하면서 overdue를 계산하고, POST로 생성하며, PATCH로 수정과 상태 변경을, DELETE로 삭제를 처리합니다. 모든 엔드포인트에서 소유권을 확인합니다.

**Vibe Coding 활용 예시**를 보시면, "BE-04 태스크를 구현해줘"라고 요청하면서 구체적인 요구사항을 명시했습니다. 그 결과 auth.service.ts, auth.controller.ts, auth.routes.ts, 그리고 10개의 테스트 케이스까지 자동으로 생성되었습니다. 이것이 Vibe Coding의 힘입니다.

---

## 6. 프론트엔드 개발 (4분)

프론트엔드도 7개의 태스크로 개발했습니다.

**FE-01은 프로젝트 초기화**입니다. Vite, React 19, TypeScript를 설정하고, todo.types.ts와 member.types.ts 같은 공통 타입을 정의했습니다.

**FE-02는 API Service 레이어**입니다. authService는 signup, login, logout, refreshToken 메서드를 제공하고, todoService는 getAll, create, update, remove, complete, revert 메서드를 제공합니다. 이렇게 API 호출 로직을 별도 레이어로 분리하면 컴포넌트가 간결해지고 재사용성이 높아집니다.

**FE-03은 인증 페이지**입니다. SignupPage는 회원가입 폼을, LoginPage는 로그인 폼을 제공합니다. 클라이언트 측에서 입력을 검증하고, 에러 메시지를 표시합니다.

**FE-04는 할 일 목록**입니다. TodoListPage는 목록을 렌더링하고, TodoItem은 개별 아이템 컴포넌트입니다. useTodos 훅으로 상태를 관리하며, Protected Route를 구현하여 미인증 사용자는 로그인 페이지로 리다이렉트됩니다.

**FE-05는 생성과 수정 페이지**입니다. TodoNewPage는 생성 폼을, TodoEditPage는 수정 폼을 제공하며, datetime-local 타입의 input으로 날짜와 시간을 함께 입력받습니다.

**FE-06은 Overdue 시각화**입니다. todo.overdue가 true이면 빨간 배지와 "마감 초과" 레이블을 표시합니다.

**FE-07은 반응형 UI**입니다. 모바일은 360px 이상, 데스크탑은 1280px 이상을 지원하며, 터치 타겟은 최소 44px로 설정했습니다. 다크모드도 지원합니다.

**상태 관리 예시**를 보시면, useTodos 훅에서 todos 배열과 filter 상태를 관리합니다. filteredTodos는 useMemo로 계산하여, filter가 'pending'이면 PENDING 상태만, 'done'이면 DONE 상태만, 'all'이면 전체를 반환합니다. 이렇게 하면 필터링 성능이 최적화됩니다.

---

## 7. 테스트 (3분)

테스트는 프로젝트의 품질을 보장하는 핵심입니다. 저는 총 119개의 자동화 테스트를 작성했습니다.

**백엔드 테스트는 Jest와 Supertest를 사용**했습니다. Unit 테스트 5개, Integration 테스트 30개로 총 35개의 테스트를 작성했고, 커버리지는 94%입니다. app.test.ts에서 5개, auth.test.ts에서 10개, todo.test.ts에서 20개의 테스트를 작성했습니다.

**프론트엔드 테스트는 Vitest와 Testing Library를 사용**했습니다. 서비스 계층 19개, 훅 12개, 컴포넌트 12개, 페이지 42개로 총 84개의 테스트를 작성했고, 커버리지는 95%입니다.

**E2E 테스트는 Playwright를 사용**했습니다. 정상 시나리오 11개, 예외 시나리오 12개, 엔드투엔드 시나리오 2개를 작성했습니다.

**테스트 자동화 사례를 보시면**, SC-E2E-01은 "직장인 김민준" 페르소나의 전체 시나리오를 테스트합니다. 회원가입을 완료하고, 로그인하여 할 일 3개를 생성하는데, 하나는 내일 마감, 하나는 오늘 오후 마감, 하나는 어제 마감입니다. 어제 마감인 "주간 보고서"에는 overdue 배지가 표시되어야 합니다. 그 다음 "회의 준비"를 완료 처리하면 취소선이 그어지고, 완료 탭을 선택하면 "회의 준비"만 표시되어야 합니다.

**이런 복잡한 시나리오도 Vibe Coding으로 쉽게 작성할 수 있습니다.** "SC-E2E-01 시나리오를 Playwright로 구현해줘"라고 요청하고, 각 단계를 명시하면 AI가 전체 테스트 코드를 생성해줍니다.

---

## 8. 배포 (3분)

배포는 Vercel과 Supabase를 활용했습니다.

**아키텍처를 보시면**, 프론트엔드는 Vercel에서 정적 사이트로 호스팅되고, 백엔드는 Vercel Serverless Function으로 배포되며, 데이터베이스는 Supabase의 PostgreSQL 17을 사용합니다.

**배포 설정은 vercel.json 파일**로 관리했습니다. 백엔드는 api/index.ts를 빌드 소스로 지정하고, 모든 /api 요청과 /docs 요청을 이 파일로 라우팅합니다. 프론트엔드는 모든 요청을 index.html로 리다이렉트하여 SPA 라우팅을 지원합니다.

**환경변수는 Vercel 대시보드에서 설정**했습니다. 백엔드에는 DATABASE_URL, JWT_SECRET, JWT_REFRESH_SECRET, CORS_ORIGIN, NODE_ENV를 설정했고, 프론트엔드에는 VITE_API_URL을 설정했습니다.

**CI/CD 파이프라인은 완전히 자동화**되어 있습니다. GitHub에 코드를 푸시하면, Vercel이 자동으로 빌드를 시작하고, 테스트를 실행한 후, 빌드가 성공하면 자동으로 프로덕션에 배포하며, Health Check까지 수행합니다. 도메인도 자동으로 할당됩니다.

---

## 9. 결과 및 데모 (3분)

이제 실제 결과물을 보여드리겠습니다.

**서비스 URL은 3개**입니다. 프론트엔드는 my-todolist-app.vercel.app, 백엔드 API는 my-todolist-api.vercel.app, API 문서는 /docs 경로에서 확인할 수 있습니다.

**주요 기능을 시연**해드리겠습니다.

첫째, 회원가입과 로그인입니다. 이메일 중복을 검사하고, 비밀번호 정책을 검증하며, JWT 토큰을 발급합니다.

둘째, 할 일 관리입니다. 할 일을 생성할 때 제목, 설명, 마감일을 입력할 수 있습니다. 목록 조회에서는 탭 필터로 전체, 진행중, 완료를 전환할 수 있고, 완료 처리와 완료 취소, 수정, 삭제가 모두 가능합니다.

셋째, 마감 초과 알림입니다. 마감일이 지난 항목에는 빨간 배지와 "마감 초과" 레이블이 표시됩니다.

넷째, 다크모드입니다. 시스템 테마와 연동되며, 수동으로도 전환할 수 있습니다.

다섯째, 다국어 지원입니다. 한국어, 영어, 일본어 3개 언어를 지원합니다.

**성능 지표를 보시면**, 모든 목표를 달성했습니다. API 응답 시간은 목표 500ms에 비해 평균 40ms로 훨씬 빠르고, 할 일 목록 조회는 목표 1초에 비해 평균 3.6ms입니다. 테스트 커버리지는 백엔드 94%, 프론트엔드 95%이며, 자동화 테스트는 119개 모두 통과했습니다.

---

## 10. 회고 및 배운 점 (3분)

마지막으로 Vibe Coding을 경험하면서 느낀 점을 공유하겠습니다.

**Vibe Coding의 장점은 크게 3가지**입니다.

첫째, **개발 속도가 비약적으로 향상**됩니다. 저는 단 4일 만에 풀스택 애플리케이션을 완성했습니다. 보일러플레이트 코드를 자동으로 생성하고, 테스트 코드까지 자동화할 수 있었습니다.

둘째, **품질이 향상**됩니다. 119개의 자동화 테스트를 작성했고, 커버리지는 94~95%에 달합니다. TypeScript의 strict 모드를 활용하여 타입 안정성도 확보했습니다.

셋째, **학습 효과**가 뛰어납니다. 최신 기술 스택을 빠르게 습득할 수 있었고, 베스트 프랙티스를 적용하며, 아키텍처 패턴을 깊이 이해할 수 있었습니다.

**물론 도전 과제도 있었습니다.**

첫째, **프롬프트 엔지니어링**입니다. 명확한 요구사항을 정의하고, 컨텍스트를 관리하며, 단계별로 검증하는 것이 중요합니다.

둘째, **AI 생성 코드 검토**입니다. 보안 취약점을 확인하고, 비즈니스 로직을 검증하며, 테스트 코드의 신뢰성을 확인해야 합니다.

셋째, **통합 과정**입니다. 프론트엔드와 백엔드의 API 연동, 배포 환경 설정, CORS 정책 관리 등에서 세심한 주의가 필요했습니다.

**현재 MVP 범위**는 기본 CRUD 기능, 인증/인가, 마감 초과 알림을 포함합니다. **향후 개선 계획**으로는 할 일 정렬 기능, 실시간 알림, 통계 대시보드, 협업 기능 등을 추가하려고 합니다.

**Vibe Coding을 시작하려는 분들께 권장 사항**을 드리자면,

첫째, **명확한 설계를 먼저** 하세요. 도메인 정의서, PRD, 아키텍처 다이어그램을 작성하세요.

둘째, **단계별로 진행**하세요. 작은 태스크로 분할하고, 각 단계를 검증하며, 점진적으로 개선하세요.

셋째, **테스트를 자동화**하세요. TDD 접근으로 높은 커버리지를 유지하고, E2E 시나리오를 작성하세요.

넷째, **문서화**하세요. 프로젝트 메모리를 관리하고, README를 작성하며, API 문서를 Swagger로 자동 생성하세요.

---

## 클로징 (30초)

오늘 발표를 통해 Vibe Coding이라는 새로운 개발 패러다임과, 이를 활용한 실제 프로젝트 사례를 공유했습니다.

Vibe Coding은 단순히 개발 속도를 높이는 것을 넘어, 개발자가 더 창의적이고 전략적인 사고에 집중할 수 있게 해줍니다. "어떻게"보다 "무엇을"에 집중하면서, 더 나은 제품을 만들 수 있었습니다.

여러분도 Vibe Coding을 활용해서 여러분의 아이디어를 빠르게 실현해보시기 바랍니다.

**감사합니다!**

질문이 있으시면 편하게 해주세요.

---

## 예상 질문 및 답변

**Q1: AI가 생성한 코드의 품질을 어떻게 보장하나요?**

A: 좋은 질문입니다. 세 가지 방법으로 품질을 보장합니다. 첫째, TypeScript의 strict 모드로 타입 안정성을 확보합니다. 둘째, 자동화 테스트를 119개 작성하여 커버리지 94~95%를 달성했습니다. 셋째, 코드 리뷰를 통해 보안 취약점과 비즈니스 로직을 검증합니다. AI는 초안을 생성하지만, 최종 품질은 개발자가 책임집니다.

**Q2: Vibe Coding으로 개발하면 개발 실력이 떨어지지 않나요?**

A: 오히려 반대입니다. Vibe Coding은 "어떻게"보다 "무엇을"에 집중하게 해줍니다. 문법을 외우는 대신, 아키텍처를 설계하고, 요구사항을 분석하며, 비즈니스 로직을 검증하는 능력이 더 중요해집니다. 또한 AI가 생성한 코드를 읽고 이해하는 과정에서 다양한 패턴과 베스트 프랙티스를 빠르게 학습할 수 있었습니다.

**Q3: 프로젝트 규모가 커지면 Vibe Coding이 효과적일까요?**

A: 프로젝트 규모가 커질수록 오히려 더 효과적입니다. 단, 명확한 설계와 문서화가 전제되어야 합니다. 도메인 정의서, PRD, 아키텍처 다이어그램 같은 문서를 체계적으로 관리하면, AI가 프로젝트 전체 컨텍스트를 이해하고 일관된 코드를 생성할 수 있습니다. 저는 프로젝트 메모리를 MEMORY.md 파일로 관리하면서 모든 중요한 결정과 패턴을 기록했습니다.

**Q4: Vibe Coding으로 개발할 때 가장 중요한 것은 무엇인가요?**

A: 프롬프트 엔지니어링입니다. 명확하고 구체적인 요구사항을 전달해야 정확한 결과물을 얻을 수 있습니다. 예를 들어, "로그인 기능 만들어줘"보다는 "POST /api/auth/login 엔드포인트를 만들어줘. 이메일과 비밀번호를 받아서 bcrypt로 검증하고, JWT Access Token(15분)과 Refresh Token(7일)을 발급해줘"라고 구체적으로 요청하는 것이 좋습니다.

**Q5: Claude Code 외에 다른 도구도 사용할 수 있나요?**

A: 물론입니다. GitHub Copilot, Cursor, Windsurf 등 다양한 AI 코딩 도구를 활용할 수 있습니다. 중요한 것은 도구 자체가 아니라, AI와 협업하는 방식입니다. 명확한 설계, 구체적인 요구사항, 체계적인 문서화라는 원칙은 어떤 도구를 사용하든 동일하게 적용됩니다.

**Q6: 배포 과정에서 어려웠던 점은 무엇인가요?**

A: 백엔드를 Vercel Serverless Function으로 배포할 때, vercel.json 설정에서 dest 경로에 .ts 확장자를 명시해야 한다는 점을 알게 되는 데 시간이 걸렸습니다. 또한 CORS 정책을 프론트엔드 도메인으로 제한하는 것도 중요했습니다. 하지만 이런 이슈들도 Claude Code에게 에러 메시지를 보여주고 해결 방법을 물어보면 빠르게 해결할 수 있었습니다.

**Q7: 테스트 코드도 AI가 작성했나요?**

A: 네, 대부분의 테스트 코드를 AI가 생성했습니다. 예를 들어, "SC-E2E-01 시나리오를 Playwright로 구현해줘"라고 요청하면, 전체 테스트 코드를 생성해줍니다. 하지만 생성된 테스트 코드를 실행해보고, 커버리지를 확인하며, 누락된 케이스를 추가하는 것은 제가 직접 검토했습니다.

**Q8: 4일 개발에서 시간 배분은 어떻게 했나요?**

A: 첫째 날은 백엔드 개발(BE-01~BE-07)에 집중했습니다. 둘째 날과 셋째 날은 프론트엔드 개발(FE-01~FE-07)을 진행했고, 마지막 날은 테스트와 배포에 할애했습니다. 하지만 실제로는 각 태스크를 완료할 때마다 바로 테스트를 작성했기 때문에, 마지막 날은 E2E 테스트와 배포 설정에만 집중할 수 있었습니다.

**Q9: Refresh Token은 왜 도입했나요?**

A: 보안과 사용자 경험 두 가지를 모두 개선하기 위해서입니다. Access Token의 만료 시간을 짧게(15분) 설정하면 보안은 강화되지만, 사용자는 자주 재로그인해야 합니다. Refresh Token을 도입하면, Access Token이 만료되어도 Refresh Token으로 자동 갱신할 수 있어 사용자는 재로그인 없이 서비스를 계속 이용할 수 있습니다. 또한 Token Rotation 방식으로 Refresh Token도 갱신하여 보안을 더욱 강화했습니다.

**Q10: 향후 계획은 무엇인가요?**

A: 현재 MVP에서 Post-MVP로 확장할 계획입니다. 할 일 정렬 기능, 실시간 알림, 통계 대시보드, 그리고 협업 기능(공유 할 일)을 추가하려고 합니다. 또한 성능 최적화와 접근성 개선도 진행할 예정입니다. Vibe Coding을 활용하면 이런 기능들도 빠르게 추가할 수 있을 것으로 기대합니다.
